"""
Malware and Threat Intelligence Module
Malware analysis, threat intelligence feeds, VirusTotal/AlienVault integration
"""

import re
from datetime import datetime
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse
import requests

from utils.osint_utils import OSINTUtils
from utils.result_normalizer import normalize_result


class MalwareThreatIntelligence(OSINTUtils):
    """Comprehensive malware and threat intelligence gathering"""

    def __init__(self):
        super().__init__()
        self.results = {}
        self.virustotal_api_key = self.get_api_key("virustotal")
        self.alienvault_api_key = self.get_api_key("alienvault")
        self.malware_bazaar_api_key = self.get_api_key("malware_bazaar")

    def check_rate_limit(self, service: str) -> bool:
        """Check if we're within rate limits for a service"""
        # Simple rate limiting - could be enhanced with actual rate limiting
        return True

    def analyze_malware_threats(self, target: str) -> Dict:
        """
        Comprehensive malware and threat intelligence analysis

        Args:
            target: File hash, URL, domain, IP, or search query

        Returns:
            Standardized result dict
        """
        self.logger.info(f"Starting malware threat analysis for: {target}")

        try:
            self.results = {
                "target": target,
                "timestamp": datetime.now().isoformat(),
                "hash_analysis": self.analyze_file_hash(target),
                "url_analysis": self.analyze_malicious_url(target),
                "domain_analysis": self.analyze_malicious_domain(target),
                "ip_analysis": self.analyze_malicious_ip(target),
                "threat_feeds": self.gather_threat_feeds(target),
                "malware_databases": self.search_malware_databases(target),
                "behavioral_analysis": self.analyze_behavioral_indicators(target),
                "threat_intelligence": self.gather_threat_intelligence(target),
            }

            return normalize_result({"status": "success", "data": self.results})

        except Exception as e:
            self.logger.error(f"Malware threat analysis failed: {e}")
            return normalize_result({"status": "error", "error": str(e)})

    def analyze_file_hash(self, file_hash: str) -> Optional[Dict]:
        """Analyze file hash for malware indicators"""
        if not self.is_valid_hash(file_hash):
            return None

        results = {}

        # VirusTotal analysis
        vt_results = self.analyze_virustotal(file_hash)
        if vt_results:
            results["virustotal"] = vt_results

        # Malware Bazaar analysis
        bazaar_results = self.analyze_malware_bazaar(file_hash)
        if bazaar_results:
            results["malware_bazaar"] = bazaar_results

        # Hybrid Analysis (if available)
        hybrid_results = self.analyze_hybrid_analysis(file_hash)
        if hybrid_results:
            results["hybrid_analysis"] = hybrid_results

        return results

    def is_valid_hash(self, hash_str: str) -> bool:
        """Validate if string is a valid file hash"""
        hash_patterns = {
            32: re.compile(r"^[a-fA-F0-9]{32}$"),  # MD5
            40: re.compile(r"^[a-fA-F0-9]{40}$"),  # SHA1
            64: re.compile(r"^[a-fA-F0-9]{64}$"),  # SHA256
            128: re.compile(r"^[a-fA-F0-9]{128}$"),  # SHA512
        }

        hash_len = len(hash_str)
        return hash_len in hash_patterns and bool(
            hash_patterns[hash_len].match(hash_str)
        )

    def analyze_virustotal(self, file_hash: str) -> Optional[Dict]:
        """Analyze file hash using VirusTotal API"""
        if not self.virustotal_api_key:
            return None

        if not self.check_rate_limit("virustotal"):
            return None

        try:
            url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
            headers = {"x-apikey": self.virustotal_api_key}

            response = self.make_request(url, headers=headers)
            if response and response.status_code == 200:
                data = response.json()
                attributes = data.get("data", {}).get("attributes", {})

                return {
                    "hash": file_hash,
                    "detection_ratio": f"{attributes.get('last_analysis_stats', {}).get('malicious', 0)}/{attributes.get('last_analysis_stats', {}).get('total', 0)}",
                    "names": attributes.get("names", []),
                    "file_type": attributes.get("type_description", "unknown"),
                    "size": attributes.get("size", 0),
                    "first_seen": attributes.get("first_submission_date", "unknown"),
                    "last_analysis": attributes.get("last_analysis_date", "unknown"),
                    "threat_names": (
                        list(attributes.get("popular_threat_name", {}).keys())
                        if attributes.get("popular_threat_name")
                        else []
                    ),
                }

        except Exception as e:
            self.logger.error(f"VirusTotal analysis failed: {e}")

        return None

    def analyze_malware_bazaar(self, file_hash: str) -> Optional[Dict]:
        """Analyze file hash using Malware Bazaar API"""
        if not self.malware_bazaar_api_key:
            return None

        if not self.check_rate_limit("malware_bazaar"):
            return None

        try:
            url = "https://mb-api.abuse.ch/api/v1/"
            data = {"query": "get_info", "hash": file_hash}

            response = requests.post(url, json=data, timeout=30)
            if response and response.status_code == 200:
                data = response.json()
                if data.get("query_status") == "ok":
                    sample_data = data.get("data", [{}])[0]
                    return {
                        "hash": file_hash,
                        "file_name": sample_data.get("file_name", "unknown"),
                        "file_type": sample_data.get("file_type", "unknown"),
                        "signature": sample_data.get("signature", "unknown"),
                        "tags": sample_data.get("tags", []),
                        "first_seen": sample_data.get("first_seen", "unknown"),
                        "last_seen": sample_data.get("last_seen", "unknown"),
                        "intelligence": sample_data.get("intelligence", {}),
                    }

        except Exception as e:
            self.logger.error(f"Malware Bazaar analysis failed: {e}")

        return None

    def analyze_hybrid_analysis(self, file_hash: str) -> Optional[Dict]:
        """Analyze file hash using Hybrid Analysis (if API available)"""
        # Hybrid Analysis requires API key and has rate limits
        return {
            "hash": file_hash,
            "analysis_available": False,
            "reason": "API key not configured",
        }

    def analyze_malicious_url(self, url: str) -> Optional[Dict]:
        """Analyze URL for malicious indicators"""
        if not self.is_valid_url(url):
            return None

        results = {}

        # VirusTotal URL analysis
        vt_url_results = self.analyze_url_virustotal(url)
        if vt_url_results:
            results["virustotal"] = vt_url_results

        # URL reputation checks
        reputation_results = self.check_url_reputation(url)
        if reputation_results:
            results["reputation"] = reputation_results

        # Phishing detection
        phishing_results = self.detect_phishing_url(url)
        if phishing_results:
            results["phishing_analysis"] = phishing_results

        return results

    def is_valid_url(self, url: str) -> bool:
        """Validate if string is a valid URL"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except (ValueError, TypeError):
            return False

    def analyze_url_virustotal(self, url: str) -> Optional[Dict]:
        """Analyze URL using VirusTotal API"""
        if not self.virustotal_api_key:
            return None

        if not self.check_rate_limit("virustotal"):
            return None

        try:
            # First submit URL for analysis
            submit_url = "https://www.virustotal.com/api/v3/urls"
            headers = {
                "x-apikey": self.virustotal_api_key,
                "Content-Type": "application/x-www-form-urlencoded",
            }
            data = f"url={url}"

            submit_response = requests.post(
                submit_url, data=data, headers=headers, timeout=30
            )
            if submit_response and submit_response.status_code == 200:
                submit_data = submit_response.json()
                analysis_id = submit_data.get("data", {}).get("id")

                if analysis_id:
                    # Get analysis results
                    analysis_url = (
                        f"https://www.virustotal.com/api/v3/analyses/{analysis_id}"
                    )
                    analysis_response = self.make_request(analysis_url, headers=headers)

                    if analysis_response and analysis_response.status_code == 200:
                        analysis_data = analysis_response.json()
                        stats = (
                            analysis_data.get("data", {})
                            .get("attributes", {})
                            .get("stats", {})
                        )

                        return {
                            "url": url,
                            "detection_ratio": f"{stats.get('malicious', 0)}/{stats.get('total', 0)}",
                            "harmless": stats.get("harmless", 0),
                            "malicious": stats.get("malicious", 0),
                            "suspicious": stats.get("suspicious", 0),
                            "undetected": stats.get("undetected", 0),
                        }

        except Exception as e:
            self.logger.error(f"VirusTotal URL analysis failed: {e}")

        return None

    def check_url_reputation(self, url: str) -> Dict:
        """Check URL reputation across multiple sources"""
        return {
            "url": url,
            "reputation_score": "unknown",
            "blacklist_status": [],
            "categories": [],
            "risk_level": "unknown",
        }

    def detect_phishing_url(self, url: str) -> Dict:
        """Detect phishing indicators in URL"""
        phishing_indicators = {
            "suspicious_tld": self.check_suspicious_tld(url),
            "typosquatting": self.check_typosquatting(url),
            "url_shortener": self.check_url_shortener(url),
            "suspicious_keywords": self.check_suspicious_keywords(url),
            "homoglyphs": self.check_homoglyphs(url),
        }

        risk_score = sum(
            1 for indicator, detected in phishing_indicators.items() if detected
        )

        return {
            "url": url,
            "phishing_indicators": phishing_indicators,
            "risk_score": risk_score,
            "risk_level": (
                "high" if risk_score >= 3 else "medium" if risk_score >= 1 else "low"
            ),
        }

    def check_suspicious_tld(self, url: str) -> bool:
        """Check for suspicious top-level domains"""
        suspicious_tlds = [".tk", ".ml", ".ga", ".cf", ".gq", ".xyz", ".top", ".club"]
        parsed = urlparse(url)
        return any(parsed.netloc.endswith(tld) for tld in suspicious_tlds)

    def check_typosquatting(self, url: str) -> bool:
        """Check for typosquatting attempts"""
        # This would require a list of common domains to check against
        return False

    def check_url_shortener(self, url: str) -> bool:
        """Check if URL uses shortening services"""
        shorteners = ["bit.ly", "tinyurl.com", "goo.gl", "t.co", "ow.ly"]
        parsed = urlparse(url)
        return parsed.netloc in shorteners

    def check_suspicious_keywords(self, url: str) -> bool:
        """Check for suspicious keywords in URL"""
        suspicious_words = ["login", "password", "bank", "paypal", "secure", "verify"]
        url_lower = url.lower()
        return any(word in url_lower for word in suspicious_words)

    def check_homoglyphs(self, url: str) -> bool:
        """Check for homoglyph attacks (similar-looking characters)"""
        # Basic check for common homoglyphs
        homoglyphs = {"rn": "m", "cl": "d", "vv": "w"}
        url_lower = url.lower()
        return any(
            url_lower.replace(old, new) != url_lower for old, new in homoglyphs.items()
        )

    def analyze_malicious_domain(self, domain: str) -> Optional[Dict]:
        """Analyze domain for malicious indicators"""
        if not self.is_valid_domain(domain):
            return None

        return {
            "domain": domain,
            "reputation": self.check_domain_reputation(domain),
            "blacklist_status": self.check_domain_blacklists(domain),
            "dns_analysis": self.analyze_domain_dns(domain),
            "ssl_analysis": self.analyze_domain_ssl(domain),
            "threat_intelligence": self.gather_domain_threats(domain),
        }

    def is_valid_domain(self, domain: str) -> bool:
        """Validate if string is a valid domain name"""
        domain_pattern = re.compile(
            r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$"
        )
        return bool(domain_pattern.match(domain))

    def check_domain_reputation(self, domain: str) -> Dict:
        """Check domain reputation"""
        return {
            "domain": domain,
            "reputation_score": "unknown",
            "categories": [],
            "risk_level": "unknown",
        }

    def check_domain_blacklists(self, domain: str) -> List[str]:
        """Check domain against known blacklists"""
        # This would check multiple blacklist services
        return []

    def analyze_domain_dns(self, domain: str) -> Dict:
        """Analyze domain DNS records"""
        return {
            "domain": domain,
            "a_records": [],
            "mx_records": [],
            "ns_records": [],
            "txt_records": [],
            "suspicious_patterns": [],
        }

    def analyze_domain_ssl(self, domain: str) -> Dict:
        """Analyze domain SSL certificate"""
        return {
            "domain": domain,
            "certificate_valid": "unknown",
            "issuer": "unknown",
            "valid_from": "unknown",
            "valid_until": "unknown",
            "self_signed": "unknown",
        }

    def gather_domain_threats(self, domain: str) -> Dict:
        """Gather threat intelligence for domain"""
        return {
            "domain": domain,
            "threat_categories": [],
            "associated_malware": [],
            "c2_servers": [],
            "threat_actors": [],
        }

    def analyze_malicious_ip(self, ip: str) -> Optional[Dict]:
        """Analyze IP address for malicious indicators"""
        if not self.is_valid_ip(ip):
            return None

        return {
            "ip": ip,
            "reputation": self.check_ip_reputation(ip),
            "blacklist_status": self.check_ip_blacklists(ip),
            "geolocation": self.get_ip_geolocation(ip),
            "threat_intelligence": self.gather_ip_threats(ip),
        }

    def is_valid_ip(self, ip: str) -> bool:
        """Validate if string is a valid IP address"""
        try:
            import ipaddress

            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False

    def check_ip_reputation(self, ip: str) -> Dict:
        """Check IP reputation"""
        return {
            "ip": ip,
            "reputation_score": "unknown",
            "categories": [],
            "risk_level": "unknown",
        }

    def check_ip_blacklists(self, ip: str) -> List[str]:
        """Check IP against known blacklists"""
        return []

    def get_ip_geolocation(self, ip: str) -> Dict:
        """Get IP geolocation information"""
        return {
            "ip": ip,
            "country": "unknown",
            "city": "unknown",
            "asn": "unknown",
            "organization": "unknown",
        }

    def gather_ip_threats(self, ip: str) -> Dict:
        """Gather threat intelligence for IP"""
        return {
            "ip": ip,
            "threat_categories": [],
            "associated_malware": [],
            "c2_activity": [],
            "threat_actors": [],
        }

    def gather_threat_feeds(self, target: str) -> Dict:
        """Gather intelligence from threat feeds"""
        feeds = {}

        # AlienVault OTX
        otx_results = self.gather_alienvault_otx(target)
        if otx_results:
            feeds["alienvault_otx"] = otx_results

        # Other threat feeds would be added here

        return feeds

    def gather_alienvault_otx(self, target: str) -> Optional[Dict]:
        """Gather intelligence from AlienVault OTX"""
        if not self.alienvault_api_key:
            return None

        if not self.check_rate_limit("alienvault"):
            return None

        try:
            # AlienVault OTX API calls would go here
            return {
                "target": target,
                "pulses": [],
                "threat_indicators": [],
                "passive_dns": [],
            }

        except Exception as e:
            self.logger.error(f"AlienVault OTX gathering failed: {e}")

        return None

    def search_malware_databases(self, target: str) -> Dict[str, Any]:
        """Search various malware databases"""
        databases: Dict[str, Any] = {}

        # Malware Database searches would go here
        databases["total_results"] = 0
        databases["sources"] = []

        return databases

    def analyze_behavioral_indicators(self, target: str) -> Dict:
        """Analyze behavioral indicators of compromise"""
        return {
            "target": target,
            "behavioral_indicators": [],
            "anomaly_score": "unknown",
            "confidence_level": "unknown",
        }

    def gather_threat_intelligence(self, target: str) -> Dict:
        """Gather comprehensive threat intelligence"""
        return {
            "target": target,
            "threat_actors": [],
            "campaigns": [],
            "malware_families": [],
            "tactics_techniques_procedures": [],
            "indicators_of_compromise": [],
        }

    def monitor_threats(self, indicators: List[str]) -> Dict:
        """Monitor for threat indicators"""
        return {
            "indicators": indicators,
            "monitoring_status": "started",
            "alerts": [],
            "last_check": datetime.now().isoformat(),
        }
